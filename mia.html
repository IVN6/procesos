<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Organizate ya - Project: procesos </title>
    <link rel="icon" sizes="192x192" href="">

    <link rel="stylesheet" href="style.css"> 
</head>
<style>
    
    /* Generales y TipografÃ­a */
body {
    font-family: Arial, sans-serif;
    background-color: #0f0e0e;
    color: #e9ecef;
    margin: 0;
    padding: 20px;
}

h1 {
    text-align: center;
    color: #fff;
    margin-bottom: 30px;
}

/* Contenedores Principales */
.tareas-container, .tareas {
    margin: 20px auto;
    max-width: 600px;
    background: #143758; /* Color de fondo del proceso */
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.4);
    padding: 20px;
    text-align: center;
}

.tareas {
    background: #0d2136; /* Un poco mÃ¡s oscuro para la tarea actual */
}

/* Barra de Tiempo Transcurrido (Sticky) */
#tiempoTranscurridoContainer {
    background-color: #5cb315;
    color: white;
    padding: 10px 0;
    text-align: center;
    position: sticky;
    top: 0;
    z-index: 10;
    border-radius: 20px;
    font-weight: bold;
    margin-bottom: 20px;
}

/* Mensajes y Estado */
#mensajeContainer { color: #2196F3; font-weight: bold; margin-top: 15px; }
#estado { color: #4CAF50; margin-top: 15px; font-weight: bold; }

/* Barra de Progreso */
#progresoDisplay {
    height: 30px;
    background-color: #3e4858;
    border-radius: 5px;
    overflow: hidden;
    margin: 15px 0;
    border: 1px solid #143758;
}

.progreso-bar {
    height: 100%;
    width: 0%;
    background-color: #5cb315; /* Verde inicial */
    transition: width 0.5s ease-out, background-color 0.5s ease-out;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

.progreso-bar.advertencia {
    background-color: #FF5722; /* Naranja/Rojo si excede el tiempo */
}

/* Estilos de Botones (Centralizados) */
.tareas-container button, .action-controls button, .music-btn {
    font-family: 'Roboto', sans-serif;
    font-size: 16px;
    font-weight: 600;
    padding: 10px 20px;
    border: 2px solid transparent;
    border-radius: 50px;
    background-color: transparent;
    color: #fff;
    cursor: pointer;
    overflow: hidden;
    outline: none;
    transition: all 0.3s ease-in-out;
    margin: 5px;
}

/* Colores EspecÃ­ficos de Botones */
[data-proceso], #botonIniciar { border-color: #2196F3; color: #2196F3; }
#botonFinalizar { border-color: #FF5722; color: #FF5722; }
#botonPausar { border-color: #FFC107; color: #FFC107; }
#botonEstado { border-color: #4CAF50; color: #4CAF50; }

/* Efecto Hover */
.tareas-container button:hover, .action-controls button:hover, .music-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.4);
    background-color: rgba(255, 255, 255, 0.1);
}

/* Hover especÃ­ficos para llenar color */
[data-proceso]:hover, #botonIniciar:hover { background-color: #2196F3; color: #fff; }
#botonFinalizar:hover { background-color: #FF5722; color: #fff; }
#botonPausar:hover { background-color: #FFC107; color: #000; }
#botonEstado:hover { background-color: #4CAF50; color: #fff; }

/* Estilo para botÃ³n de pausa cuando estÃ¡ activo */
#botonPausar.pausado {
    background-color: #FFC107;
    color: #000;
    font-weight: bold;
}

</style>
<body>

    <h1>hazlo ya <span id="tituloProceso"></span></h1>

    <div class="header-controls">
        <button class="music-btn" id="musicButton">ğŸµ</button>
        <div id="tiempoTranscurridoContainer">Tiempo Total: 0 min</div>
    </div>

    <!-- <div id="procesosMenu" class="tareas-container">
        <h2>Selecciona tu proceso</h2>
        <button data-proceso="habitacion">ğŸ§¹ğŸª£ Organizar HabitaciÃ³n</button>
        <button data-proceso="desactivacion">ğŸŒ™ DesactivaciÃ³n ğŸ˜´(Dormir)ğŸ›Œ</button>
        <button data-proceso="activacion">ğŸŒğŸ’ª ActivaciÃ³n 70 âš’ï¸â° (MaÃ±ana)</button>
        <button data-proceso="free">ğŸš€ğŸ†“âœ¨ ActivaciÃ³n Free</button>
        <button data-proceso="cv">ğŸ“„ğŸ‘·ğŸ¿â€â™‚ï¸ Enviar CV ğŸ’¸</button>
        <button data-proceso="idiomas">ğŸŒğŸŒ SesiÃ³n de Idiomas</button>
    </div> -->
    <div id="procesosMenu" class="tareas-container">
    <h2>Selecciona tu proceso</h2>
    </div>

    <div id="tareasContainer" class="tareas">
        <div id="tareaActualDisplay"></div>
        <div id="progresoDisplay"></div> </div>
    
    <div id="mensajeContainer"></div>
    <div id="estado"></div>

    <div class="action-controls">
        <button id="botonIniciar" style="display: none;">Iniciar Proceso</button>
        <button id="botonPausar" style="display: none;">â¸ï¸ Pausar Tarea</button>
        <button id="botonFinalizar" style="display: none;">âœ… Finalizar Tarea</button>
        <button id="botonEstado" style="display: none;">ğŸ“¢ Estado Actual</button>
    </div>
     <div id="resultadosContainer" class="tareas-container" style="display: none;">
    <h2>ğŸ“Š Resultados del Proceso</h2>
    <div id="graficoBarras">
        </div>

    <iframe src="https://docs.google.com/forms/d/e/1FAIpQLSe6iokKE2prZIlQtM1rl4BjfGZ3VLAFaPYPe6BkmuMdv6utqw/viewform?embedded=true" width="95%" height="549" frameborder="0" marginheight="0" marginwidth="0">Cargandoâ€¦</iframe>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
    <script>/**
 * ===============================================/**
 * ===============================================
 * PARTE 1: ConfiguraciÃ³n y Datos
 * ===============================================
 */

// ** CONSTANTES DE MENSAJES **
// (Puedes pegar todas tus listas de mensajes aquÃ­)
const MSG = {
    ANIMO: [
        "Â¡ContinÃºa, aunque no sÃ© cÃ³mo lo haces, pero lo estÃ¡s haciendo! Â¡continÃºa!",
        "Â¡Buen trabajo, aunque no era difÃ­cil para alguien tan perfecto como yo!",
        "Â¡Casi lo logras, pero no olvides que eres afortunado de estar en mi presencia!",
        "Â¡Excelente progreso, sigue adelante... aunque no sÃ© por quÃ© te preocupas tanto, ya estÃ¡ casi hecho!",
        "Â¡Ya casi terminas, gran esfuerzo... aunque para mÃ­ esto serÃ­a pan comido!"
    ],
    ADVERTENCIA: [
        "Ten cuidado, no estÃ¡s alcanzando el nivel de eficiencia que espero.",
        "Parece que esta tarea se estÃ¡ extendiendo un poco... Â¿no crees que deberÃ­as acelerar?",
        "Â¡Jhon, eso estÃ¡ lento, apÃºrate o no serÃ¡s digno de mi presencia!",
        "Deja de ser tan lento y Â¡mete la ficha! Solo los verdaderos poderosos lo logran rÃ¡pido.",
    ],
    FELICITACION: [
        "Â¡IncreÃ­ble! Has terminado antes de lo esperado... aunque te di la oportunidad de hacerlo.",
        "Â¡FantÃ¡stico! Tu eficiencia es admirable... por ahora.",
        "Â¡Genial! Has hecho un gran trabajo y a tiempo... supongo que no fue tan difÃ­cil para ti.",
    ],
    FRASE_INICIO: [
        "Â¿Es todo? serÃ¡ tan fÃ¡cil",
        "harÃ© todo a mi manera.",
        "No necesito esforzarme, el universo me pertenece.",
    ]
};

const PROCESSES = {
    // ----------------------------------------------------
    // 1. Organizar HabitaciÃ³n
    // ----------------------------------------------------
    habitacion: {
        nombre: "Organizar HabitaciÃ³n",
        tareas: [
            { nombre: "Hacer la cama", tiempoMin: 4 },
            { nombre: "Despejar superficies", tiempoMin: 10 },
            { nombre: "Organizar esos objetos", tiempoMin: 10 },
            { nombre: "Limpiar polvo", tiempoMin: 5 },
            { nombre: "Recoger ropa sucia en", tiempoMin: 10 },
            { nombre: "barrida", tiempoMin: 10 },
            { nombre: "botar una cosa innecesaria", tiempoMin: 3 },
        ]
    },

    // ----------------------------------------------------
    // 2. Rutina DesactivaciÃ³n
    // ----------------------------------------------------
    desactivacion: {
        nombre: "Rutina DesactivaciÃ³n",
        tareas: [
            { nombre: "Desconectar pensamientos y tareas", tiempoMin: 5 },
            { nombre: "Organizar pijama", tiempoMin: 5 },
            { nombre: "Preparar ropa para maÃ±ana", tiempoMin: 3 },
            { nombre: "Rutina de skin care y cepillo", tiempoMin: 5 },
            { nombre: "Programar alarmas", tiempoMin: 2 },
            { nombre: "Preparar mochila", tiempoMin: 5 },
            { nombre: "vaso de agua", tiempoMin: 4 },
            { nombre: "Anotar 3 tareas prioritarias para maÃ±ana", tiempoMin: 4 },
            { nombre: "Escribir reflexiÃ³nes concluciones del dÃ­a", tiempoMin: 5 },
            { nombre: "tiempo en cel y cual app", tiempoMin: 4 },
            { nombre: "algo aburrido o lectura", tiempoMin: 15 },
            { nombre: "Apagar luces", tiempoMin: 3 },
        ]
    },

    // ----------------------------------------------------
    // 3. Rutina de ActivaciÃ³n  (Original)
    // ----------------------------------------------------
    activacion76: {
        nombre: "Rutina de ActivaciÃ³n base",
        tareas: [
            { nombre: `${getRandomMsg(MSG.FRASE_INICIO)} es hora de Beber agua`, tiempoMin: 3 },
            { nombre: "Ponerte los zapatos", tiempoMin: 4 },
            { nombre: "Aseo dental", tiempoMin: 5 },
            { nombre: "Tender la cama", tiempoMin: 7 },
            { nombre: "Movimiento fÃ­sico ligero. ligero", tiempoMin: 14 },
            { nombre: "concentraciÃ³n y doblar pijama", tiempoMin: 12 },
            { nombre: "entra al baÃ±o y tema", tiempoMin: 3 },
            { nombre: "Ducha", tiempoMin: 15 },
            { nombre: "pantalÃ³n y ordenar toalla", tiempoMin: 10 },
            { nombre: "Vestirse como el mejor", tiempoMin: 7 },
            { nombre: "hagase un cafÃ©", tiempoMin: 5 },
            { nombre: "PrevisiÃ³n de 3 minimos del dÃ­a", tiempoMin: 5 },
            { nombre: "separar juego, pasion y bullshit de negocio", tiempoMin: 3 },
            { nombre: "RevisiÃ³n rÃ¡pida de 3 objetivos escritos ayer", tiempoMin: 5 },
            { nombre: "Divide la primera tarea en muchas partes ", tiempoMin: 10 },
            { nombre: "Elige la mas facil y... Â¡Arrancar! ", tiempoMin: 10 },
        ]
    },

    // ----------------------------------------------------
    // 4. Rutina de ActivaciÃ³n (Final/Enfocada)
    // ----------------------------------------------------
    activacionF: {
        nombre: "Rutina de ActivaciÃ³n",
        tareas: [
            { nombre: `HidrÃ¡tate, porque el poder fluye a travÃ©s de ti. ${getRandomMsg(MSG.FRASE_INICIO)} es hora de Beber agua`, tiempoMin: 3 },
            { nombre: "PÃ³ntelos como un prÃ­ncipe, los zapatos son parte de tu grandeza. (Ponte los zapatos)", tiempoMin: 4 },
            { nombre: "Haz el aseo dental, porque tu perfecciÃ³n empieza con una sonrisa imparable. (Aseo dental)", tiempoMin: 5 },
            { nombre: "El movimiento es solo un recordatorio de tu dominio sobre el cuerpo. (Movimiento fÃ­sico ligero)", tiempoMin: 7 },
            { nombre: "Deja que tu mente sea tan frÃ­a y calculadora como tu poder. (Mindfulness o respiraciÃ³n)", tiempoMin: 5 },
            { nombre: "Tender la cama... aunque no lo necesites, el orden refleja tu perfecciÃ³n. (Tender la cama)", tiempoMin: 7 },
            { nombre: "BÃ¡Ã±ate con la frialdad del universo, refrescando tu poder. (Ducha frÃ­a o templada)", tiempoMin: 10 },
            { nombre: "Haz tu aseo personal, como quien cuida una obra maestra. (Aseo personal)", tiempoMin: 10 },
            { nombre: "VÃ­stete como el ser supremo que eres, el mundo necesita verlo. (Vestirse como el mejor)", tiempoMin: 7 },
            { nombre: "Agradece, aunque el universo ya te da todo lo que mereces. (Gratitud)", tiempoMin: 3 },
            { nombre: "Revisa y controla tu destino, porque nadie mÃ¡s lo harÃ¡ por ti. (RevisiÃ³n rÃ¡pida de objetivos)", tiempoMin: 5 },
            { nombre: "Â¡Despierta, es hora de conquistar este dÃ­a, sin excusas! (Arrancar con la primera tarea importante)", tiempoMin: 10 },
        ]
    },

    // ----------------------------------------------------
    // 5. EnvÃ­o de Hojas de Vida
    // ----------------------------------------------------
    envioCV: {
        nombre: "EnvÃ­o de Hojas de Vida",
        tareas: [
            { nombre: "Quitar distracciones y Sacar libreta para apuntes", tiempoMin: 5 },
            { nombre: "Abrir la computadora y acceder a tu currÃ­culo", tiempoMin: 5 },
            { nombre: "busca y Escoje hasta 3 ofertas de trabajo", tiempoMin: 20 },
            { nombre: "Elegir una de las tres Â¡ahora!", tiempoMin: 5 },
            { nombre: "Leer cuidadosamente los requisitos de la oferta elegida", tiempoMin: 6 },
            { nombre: "Personalizar tu currÃ­culum para la oferta seleccionada", tiempoMin: 20 },
            { nombre: "Escribir carta de presentaciÃ³n o correo para la empresa", tiempoMin: 10 },
            { nombre: "revisa ortografia", tiempoMin: 8 },
            { nombre: "Enviala hazlo Â¡ahora!", tiempoMin: 2 },
            { nombre: "Registrar la oferta en una hoja de seguimiento", tiempoMin: 5 },
            { nombre: "haz una alarma para llamar en 2 dias habiles", tiempoMin: 5 },
            { nombre: "Hacer una pausa para relajarte y recargar energÃ­as", tiempoMin: 5 },
        ]
    },

    // ----------------------------------------------------
    // 6. Aprendizaje Eficaz de Idiomas
    // ----------------------------------------------------
    idioma: {
        nombre: "Aprendizaje Eficaz de Idiomas",
        tareas: [
            { nombre: "Preparar el espacio de estudio sin distracciones", tiempoMin: 4 },
            { nombre: "Escuchar un audio corto o canciÃ³n en el idioma", tiempoMin: 5 },
            { nombre: "Leer la letra o transcripciÃ³n del audio", tiempoMin: 5 },
            { nombre: "Anotar y aprender nuevas palabras", tiempoMin: 8 },
            { nombre: "Practicar pronunciaciÃ³n repitiendo frases clave", tiempoMin: 5 },
            { nombre: "Escribir tres oraciones usando el nuevo vocabulario", tiempoMin: 10 },
            { nombre: "Leer en voz alta las oraciones escritas", tiempoMin: 5 },
            { nombre: "Realizar un ejercicio interactivo en una aplicaciÃ³n o sitio web", tiempoMin: 10 },
            { nombre: "Repasar lo aprendido en la sesiÃ³n", tiempoMin: 5 },
            { nombre: "Finalizar la sesiÃ³n con un pensamiento positivo", tiempoMin: 2 },
        ]
    },

        claseInglesOptimizada: {
        nombre: "CLASE INGLÃ‰ (120 Minutos)",
        tareas: [
            { nombre: "SETUP y Asistencia AutomÃ¡tica (Protocolo Ãºnico de encendido y conexiÃ³n a la plataforma principal)", tiempoMin: 5 },
            { nombre: "RevisiÃ³n AsÃ­ncrona (Evidencia 1): Quiz de 3 preguntas sobre tarea pasada en plataforma digital", tiempoMin: 10 },
            { nombre: "Input Gramatical Focalizado: ExplicaciÃ³n y modelado del tema central con Ã©nfasis en uso funcional", tiempoMin: 15 },
            { nombre: "PARALELO 1: PrÃ¡ctica Controlada (A2/B2 en sala; C1 con tarea de anÃ¡lisis en plataforma)", tiempoMin: 20 },
            { nombre: "Pausa Activa Larga (10 min): El profesor organiza los grupos y revisa resultados del Quiz inicial", tiempoMin: 10 },
            { nombre: "PARALELO 2: PrÃ¡ctica de Fluidez (Evidencia 2): Juego de rol por nivel, profesor graba clips de habla", tiempoMin: 25 },
            { nombre: "Feedback y CorrecciÃ³n Colectiva (Micro-LecciÃ³n): CorrecciÃ³n de los 3 errores mÃ¡s comunes escuchados", tiempoMin: 10 },
            { nombre: "Output Escrito AsÃ­ncrona (Evidencia 3): Tarea de escritura en Moodle. RecolecciÃ³n post-clase", tiempoMin: 10 },
            { nombre: "Cierre y Anuncio de Tarea (Protocolo simple: ProyecciÃ³n de tarea con un Ãºnico enlace consolidado)", tiempoMin: 10 },
            { nombre: "Encuesta de SatisfacciÃ³n Final (UX): Respuesta individual a 3 preguntas en Google Forms", tiempoMin: 5 },
        ]
    },
};// ** CONSTANTES DE COMANDOS DE VOZ **
const VOICE_COMMANDS_MAP = {
    iniciar: ['inicia', 'comienza', 'empezar', 'arranca','de una'],
    pausa: ['pausa', 'pausar', 'detener', 'alto', 'reanuda', 'espera'],
    finalizar: ['termina', 'finaliza', 'acabar', 'listo', 'siguiente'],
    silenciar: ['callate', 'silencio', 'shh', 'stop', 'mute', 'cerrar', 'calla','cÃ¡lla',],
    estado: ['estado', 'que tal', 'habla', 'presentate'], // <--- Â¡AÃ‘ADIR !
};

// ** CONSTANTES DE REACCIONES DE VOZ **
const VOICE_REACTIONS = {
    PROCESO_SELECCIONADO: [
        (nombre) => `Proceso ${nombre} seleccionado. MuÃ©strame tu valÃ­a.`,
        (nombre) => `Has elegido ${nombre}. Que empiece el espectÃ¡culo.`,
        (nombre) => `Tarea principal ${nombre} lista. No me decepciones.`,
    ],
    COMANDO_DETECTADO: [
        (accion) => ` ${accion}  Obedezco.`,
        (accion) => `${accion}detectado.`,
        (accion) => `Afirmativo, ${accion}.`,
        (accion) => `de una mijo, ${accion}.`,
    ],
    INICIO_TAREA: [
        (nombre, tiempo) => `Iniciando ${nombre}. Tienes ${tiempo} minutos. El tiempo es oro.`,
        (nombre, tiempo) => `Ahora ${nombre}. ${tiempo} minutos. Â¡No te demores!`,
    ],
    TAREA_FINALIZADA: [
        (nombre) => `Tarea ${nombre} finalizada. Bien.`,
        (nombre) => `Fin de ${nombre}. Vamos a la siguiente.`,
    ],
    PROCESO_COMPLETO: [
        "Â¡Proceso completado! Una victoria aplastante, aunque esperada.",
        "Â¡Hemos terminado! Por ahora, has cumplido mis expectativas.",
        "Proceso finalizado. Puedes respirar... por un momento.",
    ],
};

// ** ESTADO GLOBAL DE LA APLICACIÃ“N  **
const STATE = {
    procesoSeleccionado: null, // ID del proceso (e.g., 'habitacion')
    tareasRestantes: [],       // Array de tareas del proceso
    tareaActual: null,         // { nombre: 'X', tiempoMin: 10, tiempoTotalMs: 600000, inicioMs: null }
    intervaloTarea: null,      // ID del setInterval de la tarea
    intervaloGlobal: null,     // ID del setInterval del tiempo total
    tiempoInicioGlobal: null,  // Timestamp del inicio del proceso
    isPausado: false,          // Nuevo: Controla si la aplicaciÃ³n estÃ¡ en pausa
    mensajePrevioPct: 0,       // Control de mensajes de 25%
    musicPlayer: null,         // Referencia al objeto Howl
    musicPlaying: false,

    recognition: null,
    resultadosTareas: [],
};


/**
 * ===============================================
 * PARTE 2: Funciones de Utilidad
 * ===============================================
 */

// FunciÃ³n para sÃ­ntesis de voz
function hablar(textoOArray) {
    if (globalThis.speechSynthesis) {
        const synth = globalThis.speechSynthesis;
        synth.cancel(); // Detiene la voz anterior
        
        let texto;
        if (Array.isArray(textoOArray)) {
            // Si es un array, selecciona una frase al azar
            texto = getRandomMsg(textoOArray);
        } else {
            // Si es una cadena, la usa directamente
            texto = textoOArray;
        }

        const utterance = new SpeechSynthesisUtterance(texto);
        synth.speak(utterance);
    }
}

// FunciÃ³n para obtener un mensaje aleatorio
function getRandomMsg(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}

// InicializaciÃ³n del reproductor de mÃºsica (Howler.js)
function initMusic() {
    STATE.musicPlayer = new Howl({
        src: ['https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3'],
        loop: true
    });
}

function toggleMusic() {
    const btn = document.getElementById('musicButton');
    if (STATE.musicPlaying) {
        STATE.musicPlayer.pause();
        btn.textContent = 'ğŸµ';
    } else {
        STATE.musicPlayer.play();
        btn.textContent = 'ğŸ¶';
    }
    STATE.musicPlaying = !STATE.musicPlaying;
}

// FunciÃ³n para guardar el estado en el almacenamiento local
function saveState() {
    const persistState = {
        procesoSeleccionado: STATE.procesoSeleccionado,
        tareasRestantes: STATE.tareasRestantes,
        // GUARDAMOS EL HISTORIAL DE TAREAS YA TERMINADAS
        resultadosTareas: STATE.resultadosTareas || [], 
        tareaActual: STATE.tareaActual ? {
            ...STATE.tareaActual,
            tiempoTranscurridoEnTarea: Date.now() - STATE.tareaActual.inicioMs 
        } : null,
        tiempoInicioGlobal: STATE.tiempoInicioGlobal,
        isPausado: STATE.isPausado
    };
    localStorage.setItem('appState', JSON.stringify(persistState));
}
function loadState() {
    const savedState = localStorage.getItem('appState');
    if (savedState) {
        const parsedState = JSON.parse(savedState);
        
        STATE.procesoSeleccionado = parsedState.procesoSeleccionado;
        STATE.tareasRestantes = parsedState.tareasRestantes;
        STATE.tiempoInicioGlobal = parsedState.tiempoInicioGlobal;
        STATE.isPausado = parsedState.isPausado;
        // RECUPERAMOS EL HISTORIAL
        STATE.resultadosTareas = parsedState.resultadosTareas || []; 

        if (parsedState.tareaActual) {
            STATE.tareaActual = parsedState.tareaActual;
            STATE.tareaActual.inicioMs = Date.now() - parsedState.tareaActual.tiempoTranscurridoEnTarea;
        }

        return true;
    }
    return false;
}
// FunciÃ³n para formatear la hora (HH:MM)
function formatTime(date) {
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${hours}:${minutes}`;
}


/**
 * ===============================================
 * PARTE 3: LÃ³gica de la AplicaciÃ³n y Control de Estado
 * ===============================================
 */

const App = {
    // Referencias del DOM centralizadas
    DOM: {
        tituloProceso: document.getElementById('tituloProceso'),
        menu: document.getElementById('procesosMenu'),
        progreso: document.getElementById('progresoDisplay'),
        tareaActual: document.getElementById('tareaActualDisplay'),
        tiempoTotal: document.getElementById('tiempoTranscurridoContainer'),
        mensaje: document.getElementById('mensajeContainer'),
        estado: document.getElementById('estado'),
        btnIniciar: document.getElementById('botonIniciar'),
        btnPausar: document.getElementById('botonPausar'),
        btnFinalizar: document.getElementById('botonFinalizar'),
        btnEstado: document.getElementById('botonEstado'),
        btnMusic: document.getElementById('musicButton'),
    },

   init: function() {
        initMusic();
        this.addEventListeners();
        this.renderizarMenuProcesos();
        
        // AÃ‘ADIR ESTA LÃNEA AL FINAL DE INIT
        this.initVoiceRecognition(); 
        
        if (loadState() && STATE.procesoSeleccionado) {
            this.reanudarProcesoPersistente();
        } else {
            this.DOM.tiempoTotal.innerHTML = `Hora Actual: ${formatTime(new Date())}`;
        }
    },
    reanudarProcesoPersistente: function() {
        const proceso = PROCESSES[STATE.procesoSeleccionado];
        this.DOM.tituloProceso.textContent = `| ${proceso.nombre}`;
        this.DOM.menu.style.display = 'none';
        
        this.DOM.btnPausar.style.display = 'inline-block';
        this.DOM.btnFinalizar.style.display = 'inline-block';
        this.DOM.btnEstado.style.display = 'inline-block';
        
        if (STATE.isPausado) {
             this.DOM.btnPausar.textContent = 'â–¶ï¸ Reanudar Tarea';
             this.DOM.btnPausar.classList.add('pausado');
        }

        // Reanudar contadores y UI
        STATE.intervaloGlobal = setInterval(() => this.updateTiempoTotal(), 1000);
        STATE.intervaloTarea = setInterval(() => this.updateProgresoTarea(), 1000);
        
        this.updateMensaje(`âœ… Proceso **${proceso.nombre}** reanudado. Estaba en **${STATE.tareaActual.nombre}**.`);
        this.updateProgresoTarea(); // Forzar una actualizaciÃ³n de UI
    },

    addEventListeners: function() {
        // Eventos de selecciÃ³n de proceso
        this.DOM.menu.addEventListener('click', (e) => {
            if (e.target.dataset.proceso) {
                this.seleccionarProceso(e.target.dataset.proceso);
            }
        });

        // Eventos de control
        this.DOM.btnIniciar.addEventListener('click', () => this.iniciarProceso());
        this.DOM.btnPausar.addEventListener('click', () => this.togglePausa());
        this.DOM.btnFinalizar.addEventListener('click', () => this.finalizarTarea(true)); // Forzado
        this.DOM.btnEstado.addEventListener('click', () => this.mostrarEstado());
        this.DOM.btnMusic.addEventListener('click', () => toggleMusic());
    },
    // --- 3.0. Renderizado y Utilidad ---
    renderizarMenuProcesos: function() {
        this.DOM.menu.innerHTML = '<h2>Selecciona tu proceso</h2>';
        
        for (const id in PROCESSES) {
            const proceso = PROCESSES[id];
            const totalMinutos = proceso.tareas.reduce((sum, tarea) => sum + tarea.tiempoMin, 0);
            
            const button = document.createElement('button');
            button.setAttribute('data-proceso', id);
            button.setAttribute('title', `Tiempo total estimado: ${totalMinutos} minutos`);
            button.innerHTML = `${proceso.nombre} <br> <small>(~${totalMinutos} min)</small>`;
            this.DOM.menu.appendChild(button);
        }
    },
    
    // --- 3.1. GestiÃ³n de Proceso ---
    seleccionarProceso: function(procesoID) {
        if (STATE.intervaloGlobal) {
            this.updateMensaje("Â¡Alto! Hay un proceso en curso. FinalÃ­zalo primero.");
            return;
        }

        const proceso = PROCESSES[procesoID];
        if (!proceso) return;

        STATE.procesoSeleccionado = procesoID;
        STATE.tareasRestantes = [...proceso.tareas]; // Copia profunda para no modificar el original

        // Actualizar UI
        this.DOM.tituloProceso.textContent = `| ${proceso.nombre}`;
        this.DOM.menu.style.display = 'none';
        this.DOM.btnIniciar.style.display = 'inline-block';
        this.updateMensaje(`Proceso "${proceso.nombre}" listo. Â¡${getRandomMsg(MSG.FRASE_INICIO)}`);
        hablar(VOICE_REACTIONS.PROCESO_SELECCIONADO.map(f => f(proceso.nombre)));
    },

    iniciarProceso: function() {
        if (!STATE.procesoSeleccionado) return;
        
        // ConfiguraciÃ³n inicial del estado y UI
        STATE.tiempoInicioGlobal = Date.now();
        this.DOM.btnIniciar.style.display = 'none';
        this.DOM.btnPausar.style.display = 'inline-block';
        this.DOM.btnFinalizar.style.display = 'inline-block';
        this.DOM.btnEstado.style.display = 'inline-block';
        
        // Iniciar contadores globales
        STATE.intervaloGlobal = setInterval(() => this.updateTiempoTotal(), 1000);
        
        this.siguienteTarea();
        enviarEmojisGAS()
    },
    finalizarProceso: function() {
Â  Â  Â  Â  clearInterval(STATE.intervaloGlobal);
Â  Â  Â  Â  this.DOM.btnPausar.style.display = 'none';
Â  Â  Â  Â  this.DOM.btnFinalizar.style.display = 'none';
Â  Â  Â  Â  this.DOM.btnEstado.style.display = 'none';
Â  Â  Â  Â  this.DOM.tituloProceso.textContent = '';
        
        // ** Â¡NUEVO! Mostrar resultados antes de reiniciar el estado **
        this.mostrarResultados();

Â  Â  Â  Â  this.updateMensaje(`Â¡PROCESO COMPLETO! Total: ${this.DOM.tiempoTotal.textContent}. Â¡Victoria aplastante!`);
Â  Â  Â  Â  hablar("Â¡Proceso completado! Gran trabajo, inferior.");
        enviarEmojisGAS();

Â  Â  Â  Â  // Reiniciar el estado para el siguiente uso
Â  Â  Â  Â  STATE.procesoSeleccionado = null;
Â  Â  Â  Â  STATE.tiempoInicioGlobal = null;
Â  Â  Â  Â  STATE.intervaloGlobal = null;
Â  Â  Â  Â  STATE.tareasRestantes = [];
        STATE.resultadosTareas = []; // Limpiar resultados
Â  Â  },
    
    finalizarProceso: function() {
        clearInterval(STATE.intervaloGlobal);
        this.DOM.btnPausar.style.display = 'none';
        this.DOM.btnFinalizar.style.display = 'none';
        this.DOM.btnEstado.style.display = 'none';
        this.DOM.menu.style.display = 'block';
        this.DOM.tituloProceso.textContent = '';
        this.mostrarResultados(); 

        this.updateMensaje(`Â¡PROCESO COMPLETO! Total: ${this.DOM.tiempoTotal.textContent}. Â¡Victoria aplastante!`);
        hablar("Â¡Proceso completado! Gran trabajo, inferior.");

       // Reiniciar el estado
    STATE.procesoSeleccionado = null;
    STATE.tiempoInicioGlobal = null;
    STATE.intervaloGlobal = null;
    STATE.tareasRestantes = [];
    STATE.resultadosTareas = []; // Limpiar resultados
    localStorage.removeItem('appState'); // AÃ‘ADIR PARA LIMPIAR PERSISTENCIA
    },

    // --- 3.2. GestiÃ³n de Tareas ---
    siguienteTarea: function() {
        if (STATE.tareaActual) {
            // Limpiar la tarea anterior (solo si no es la primera)
            clearInterval(STATE.intervaloTarea);
            STATE.tareaActual = null;
        }
        
        if (STATE.tareasRestantes.length === 0) {
            this.finalizarProceso();
            return;
        }

        const tareaData = STATE.tareasRestantes.shift(); // Obtiene la primera tarea (FIFO)
        
        STATE.tareaActual = {
            ...tareaData,
            tiempoTotalMs: tareaData.tiempoMin * 60 * 1000,
            inicioMs: Date.now(),
            mensajePrevioPct: 0
        };

        this.updateMensaje(`Â¡Ahora! **${STATE.tareaActual.nombre}** tienes ${STATE.tareaActual.tiempoMin} minutos.`);
        hablar(`Iniciando tarea: ${STATE.tareaActual.nombre}. ${STATE.tareaActual.tiempoMin} minutos.`);

        // Iniciar el intervalo de la tarea
        STATE.intervaloTarea = setInterval(() => this.updateProgresoTarea(), 1000);
        saveState();
    },

    
    finalizarTarea: function(forzada = false) {
Â  Â  Â  Â  if (!STATE.tareaActual) return;

Â  Â  Â  Â  clearInterval(STATE.intervaloTarea);

Â  Â  Â  Â  const tiempoTranscurrido = Date.now() - STATE.tareaActual.inicioMs;
Â  Â  Â  Â  const tiempoUsadoMin = tiempoTranscurrido / 1000 / 60;
Â  Â  Â  Â  const tiempoObjetivoMin = STATE.tareaActual.tiempoMin; // NUEVO
        saveState();
Â  Â  Â  Â  // ** Â¡NUEVO! Guardar el resultado en el estado **
        STATE.resultadosTareas.push({
            nombre: STATE.tareaActual.nombre,
            objetivoMin: tiempoObjetivoMin,
            realMin: tiempoUsadoMin,
            eficiencia: (tiempoObjetivoMin / tiempoUsadoMin) * 100 // Porcentaje de eficiencia vs. tiempo real
        });
        saveState();
        // ------------------------------------------
Â  Â  Â  Â  
Â  Â  Â  Â  let mensaje;
Â  Â  Â  Â  if (tiempoUsadoMin <= tiempoObjetivoMin) {
Â  Â  Â  Â  Â  Â  mensaje = `${getRandomMsg(MSG.FELICITACION)} Â¡A tiempo! (${Math.round(tiempoUsadoMin)} min)`;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  mensaje = forzada 
Â  Â  Â  Â  Â  Â  Â  Â  ? `Tarea forzada. Te tardaste ${Math.round(tiempoUsadoMin)} min. Â¡MÃ¡s rÃ¡pido, Jhon!`
Â  Â  Â  Â  Â  Â  Â  Â  : `Tiempo excedido. Te tardaste ${Math.round(tiempoUsadoMin)} min. Â¡MÃ¡s eficiente, gusano!`;
Â  Â  Â  Â  }

Â  Â  Â  Â  this.updateMensaje(`âœ… Tarea **${STATE.tareaActual.nombre}** finalizada. ${mensaje}`);
Â  Â  Â  Â  hablar(`Tarea ${STATE.tareaActual.nombre} finalizada.`);

Â  Â  Â  Â  this.siguienteTarea();
Â  Â  },
// --- 3.3. Mostrar Resultados Finales (GrÃ¡fico de Barras) ---
    mostrarResultados: function() {
        const resultadosDiv = document.getElementById('resultadosContainer');
        const graficoDiv = document.getElementById('graficoBarras');
        const maxTiempo = Math.max(...STATE.resultadosTareas.map(r => r.objetivoMin), 
                                   ...STATE.resultadosTareas.map(r => r.realMin), 0) * 1.1; // 10% de margen

        let html = '';
        
        // TÃ­tulo de la Leyenda
        html += `<div style="font-size: 0.9em; margin-bottom: 10px;">
                    <span style="color: #4CAF50;">â—¼</span> Objetivo | 
                    <span style="color: #FFC107;">â—¼</span> Real
                 </div>`;
        
        STATE.resultadosTareas.forEach((r, index) => {
            const objetivoPct = (r.objetivoMin / maxTiempo) * 100;
            const realPct = (r.realMin / maxTiempo) * 100;
            const diferencia = Math.round(r.realMin - r.objetivoMin);
            
            // Determina el color y el Ã­cono
            let icono, colorDiferencia;
            if (diferencia <= 0) {
                icono = 'ğŸ†';
                colorDiferencia = '#4CAF50'; // Verde: mejor o igual que el objetivo
            } else {
                icono = 'ğŸŒ';
                colorDiferencia = '#FF5722'; // Rojo/Naranja: peor que el objetivo
            }
            
            // Generar la barra de visualizaciÃ³n
            html += `
                <div style="margin-bottom: 25px; text-align: left; background-color: #0d2136; padding: 10px; border-radius: 5px;">
                    <strong style="color: #fff;">${index + 1}. ${r.nombre}</strong> 
                    <span style="float: right; color: ${colorDiferencia}; font-weight: bold;">
                        ${icono} ${diferencia > 0 ? '+' : ''}${Math.round(diferencia)} min
                    </span>
                    <div style="font-size: 0.8em; color: #aaa;">
                        Obj: ${r.objetivoMin} min | Real: ${Math.round(r.realMin)} min
                    </div>
                    
                    <div style="display: flex; height: 18px; margin-top: 5px;">
                        <div style="width: ${objetivoPct}%; background-color: #4CAF50; border-radius: 3px 0 0 3px; position: relative;">
                            <div style="width: ${realPct / objetivoPct * 100}%; height: 100%; background-color: ${r.realMin > r.objetivoMin ? '#FF5722' : '#FFC107'}; opacity: 0.7; position: absolute; top: 0; left: 0; border-radius: 3px;">
                            </div>
                        </div>
                         <div style="width: ${100 - objetivoPct}%; background-color: #3e4858; border-radius: 0 3px 3px 0;"></div>
                    </div>
                </div>
            `;
        });
        
        graficoDiv.innerHTML = html;
        resultadosDiv.style.display = 'block';
        
        // Ocultar el menÃº de selecciÃ³n de procesos
        this.DOM.menu.style.display = 'none'; 
    },

    // ... El resto de tu cÃ³digo de la App
    

    // --- 3.4. Funciones de ActualizaciÃ³n de UI ---
    updateTiempoTotal: function() {
        if (STATE.isPausado) return;
        
        const elapsedMs = Date.now() - STATE.tiempoInicioGlobal;
        const totalMin = Math.round(elapsedMs / 1000 / 60);
        
        const horaActual = formatTime(new Date()); // Usar la nueva funciÃ³n
        const horaEstimadaFinal = this.calcularTiempoFinalizacion();

        let displayTxt = `Total: ${totalMin} min | Ahora: ${horaActual}`;
        
        if (horaEstimadaFinal) {
            displayTxt += ` | Fin Est.: ${horaEstimadaFinal}`;
        }
        
        this.DOM.tiempoTotal.innerHTML = displayTxt; // Usar innerHTML
    },
    // --- 3.4. GestiÃ³n de Reconocimiento de Voz ---
    initVoiceRecognition: function() {
        // Verifica si la API estÃ¡ disponible
        const SpeechRecognition = globalThis.SpeechRecognition || globalThis.webkitSpeechRecognition;

        if (!SpeechRecognition) {
            this.updateMensaje("âŒ **ERROR:** El reconocimiento de voz no estÃ¡ soportado en tu navegador o requiere HTTPS.");
            this.DOM.btnEstado.style.borderColor = '#FF5722'; // Mostrar error en un botÃ³n
            return;
        }

        STATE.recognition = new SpeechRecognition();
        STATE.recognition.lang = 'es-ES'; // Configura el idioma a espaÃ±ol
        STATE.recognition.interimResults = false; // Solo resultados finales
        STATE.recognition.continuous = true; // Sigue escuchando
        STATE.recognition.maxAlternatives = 1;

        // Evento de resultado: procesa lo que el usuario dijo
        STATE.recognition.onresult = (event) => {
            const comando = event.results[event.results.length - 1][0].transcript.trim().toLowerCase();
            this.procesarComandoVoz(comando);
        };

        // Evento de fin: se reinicia la escucha si estaba en modo continuo, o lo notifica.
        STATE.recognition.onend = () => {
            if (STATE.recognition) {
                // Intenta reiniciarse automÃ¡ticamente
                this.iniciarEscucha(); 
                this.DOM.estado.textContent = 'ğŸ“¢ Escuchando...';
            }
        };

        STATE.recognition.onerror = (event) => {
            console.error('Error de reconocimiento de voz:', event.error);
            this.DOM.estado.textContent = 'âŒ Error de voz. Recargando...';
        };

        this.iniciarEscucha();
    },

    iniciarEscucha: function() {
        try {
            if (STATE.recognition) {
                STATE.recognition.start();
                // OBTENER LAS PALABRAS CLAVE DEL MAPA PARA MOSTRARLAS
                const comandosDisponibles = Object.keys(VOICE_COMMANDS_MAP).join(', ');
                this.DOM.estado.textContent = `ğŸ“¢ Escuchando... (Comandos: mÃ­a ${comandosDisponibles})`;
            }
     
    } catch (e) {
            // Previene el error si ya estÃ¡ escuchando
            if (e.name !== 'InvalidStateError') {
                 console.error("Error al iniciar la escucha:", e);
            }
        }
    }
    ,

    procesarComandoVoz: function(comando) {
    // 1. ğŸ¤« VERIFICACIÃ“N DEL COMANDO DE SILENCIO (PRIORIDAD MÃXIMA)
    // Se usa 'comando' (la entrada completa) para detener la voz incluso si no dice 'mÃ­a'
    const comandosSilenciar = VOICE_COMMANDS_MAP.silenciar;
    const matchSilencio = comandosSilenciar.find(sinonimo => comando.includes(sinonimo));

    if (matchSilencio) {
        if (globalThis.speechSynthesis) {
            globalThis.speechSynthesis.cancel(); // Detiene cualquier voz en curso
            this.DOM.estado.textContent = 'ğŸ¤« Silencio activado.';
            this.updateMensaje(`ğŸ¤« Comando de Silencio (**${matchSilencio}**) detectado. Voz detenida.`);
            return; // Detiene la ejecuciÃ³n aquÃ­
        }
    }
    
    // 2. ğŸ”‘ VERIFICACIÃ“N DE LA PALABRA CLAVE ('mÃ­a')
    if (!comando.includes('mÃ­a'|| 'mia'|| 'lala' || 'lÃ¡la'|| 'lalÃ¡' || 'lÃ¡lÃ¡')) {
        this.DOM.mensaje.innerHTML = `<p style="color:#FFC107;">ğŸ™ï¸ Comando: "${comando}" | Esperando palabra clave "mÃ­a".</p>`;
        return;
    }

    // 3. ğŸ§¼ LIMPIEZA Y PROCESAMIENTO
    const comandoLimpio = comando.replace('mÃ­a'|| 'mia'|| 'lala' || 'lÃ¡la'|| 'lalÃ¡' || 'lÃ¡lÃ¡', '').trim();
    let accion = null;
    let procesoIDSeleccionado = null;
    
    // 4. Intentar seleccionar un proceso (SÃ“LO SI NO HAY UNO ACTIVO)
    if (!STATE.procesoSeleccionado) {
        // ... (Tu lÃ³gica existente para seleccionar proceso con 'comandoLimpio')
        for (const id in PROCESSES) {
            // Normalizamos el nombre del proceso para la comparaciÃ³n de voz
            const nombreNormalizado = PROCESSES[id].nombre.toLowerCase().replace(/[^a-z0-9\s]/g, '');
            
            // Buscar si el comando de voz incluye el nombre del proceso
            if (comandoLimpio.includes(nombreNormalizado.substring(0, 15))) { // Se compara una parte para tolerancia
                procesoIDSeleccionado = id;
                break;
            }
        }
    }

    if (procesoIDSeleccionado) {
        this.seleccionarProceso(procesoIDSeleccionado);
        return; // Detener aquÃ­ si se seleccionÃ³ un proceso.
    }

    // 5. Si hay proceso activo, buscar comandos de acciÃ³n (iniciar, pausa, finalizar)
    for (const actionKey in VOICE_COMMANDS_MAP) {
        const synonyms = VOICE_COMMANDS_MAP[actionKey];
        const match = synonyms.find(synonym => comandoLimpio.includes(synonym));
        
        if (match) {
            accion = actionKey;
            break;
        }
    }

    // 6. EJECUTAR ACCIÃ“N (LÃ³gica de tu aplicaciÃ³n)
    if (accion) {
        this.updateMensaje(`Comando "**${accion}**" detectado.`);
        // AÃ±ade aquÃ­ la lÃ³gica de ejecuciÃ³n (ej: this.iniciarProceso(), this.togglePausa(), this.finalizarTarea())
        switch (accion) {
            case 'iniciar':
                this.iniciarProceso();
                break;
            case 'pausa':
                this.togglePausa();
                break;
            case 'finalizar':
                this.finalizarTarea(true); // FinalizaciÃ³n forzada
                break;
            // No se necesita el caso 'silenciar' aquÃ­ porque se maneja en el paso 1.
            case 'estado':
                // Llamamos a la funciÃ³n que ya genera una respuesta de voz//  NUEVO CASO: 'estado' (Comando para hablar de nuevo)
                this.mostrarEstado(); 
                break;
        }
    } else {
        this.DOM.mensaje.innerHTML = `<p style="color:#FFC107;">ğŸ™ï¸ Comando: "${comandoLimpio}" | AcciÃ³n no reconocida.</p>`;
    }
}
    ,

    updateProgresoTarea: function() {
    
    // 1. Verificar Pausa y Tarea
    if (STATE.isPausado || !STATE.tareaActual) return; // Sale inmediatamente si estÃ¡ pausado o sin tarea

    const tarea = STATE.tareaActual;
    const tiempoTranscurrido = Date.now() - tarea.inicioMs; // CÃ¡lculo de tiempo
    const porcentaje = (tiempoTranscurrido / tarea.tiempoTotalMs) * 100;
    const tiempoUsado = tiempoTranscurrido / 1000;
    
    const min = Math.floor(tiempoUsado / 60);
    const sec = Math.floor(tiempoUsado % 60);
    
    // 1. Actualizar el Display de la Tarea y la Barra
    this.DOM.tareaActual.innerHTML = `<strong>Tarea:</strong> ${tarea.nombre} | Usado: ${min} min ${sec} seg`;
    
    const progressBar = this.DOM.progreso.querySelector('.progreso-bar') || document.createElement('div');
    progressBar.className = 'progreso-bar';
    this.DOM.progreso.appendChild(progressBar);
    
    let displayPct = Math.min(porcentaje, 100);
    progressBar.style.width = `${displayPct}%`;
    progressBar.textContent = `${Math.round(porcentaje)}%`;
    
    // 2. Control de color de advertencia
    if (porcentaje >= 100) {
        progressBar.classList.add('advertencia');
    } else {
        progressBar.classList.remove('advertencia');
    }
    
    // 3. Control de mensajes de motivaciÃ³n/advertencia
    const currentPctLevel = Math.floor(porcentaje / 25) * 25;
    
    if (currentPctLevel > tarea.mensajePrevioPct) {
        tarea.mensajePrevioPct = currentPctLevel;
        
        let msg;
        if (porcentaje <= 100) {
            // Mensajes de Ã¡nimo
            const index = Math.min(currentPctLevel / 25 - 1, MSG.ANIMO.length - 1);
            msg = `${MSG.ANIMO[index]} (${currentPctLevel}%)`;
        } else {
            // Mensajes de advertencia (al exceder el tiempo)
            msg = `${getRandomMsg(MSG.ADVERTENCIA)} (Â¡Tiempo lÃ­mite excedido! ${Math.round(porcentaje)}%)`;
        }

        this.updateMensaje(msg);
        hablar(msg);
    }
    
    // 4. Persistencia: Guarda el estado solo si estÃ¡ ACTIVO
    saveState(); // Â¡AÃ‘ADE AQUÃ LA FUNCIÃ“N SAVE STATE!
    },
    updateMensaje: function(texto) {
        this.DOM.mensaje.innerHTML = `<p>${texto}</p>`;
    },

    mostrarEstado: function() {
        if (!STATE.tareaActual) {
            this.DOM.estado.textContent = "No hay tareas en progreso.";
            hablar("No hay tareas en progreso.");
            return;
        }

        const tarea = STATE.tareaActual;
        const tiempoTranscurrido = Date.now() - tarea.inicioMs;
        const porcentaje = (tiempoTranscurrido / tarea.tiempoTotalMs) * 100;

        const estadoTxt = `Estado de "${tarea.nombre}": ${Math.round(porcentaje)}% completado.`;
        this.DOM.estado.textContent = estadoTxt;
        hablar(estadoTxt);
    },

    togglePausa: function() {
        if (!STATE.tareaActual && !STATE.intervaloGlobal) return;

        STATE.isPausado = !STATE.isPausado;
        
        const btn = this.DOM.btnPausar;
        if (STATE.isPausado) {
            btn.textContent = 'â–¶ï¸ Reanudar Tarea';
            btn.classList.add('pausado');
            hablar("Proceso pausado. No me hagas esperar mucho.");
        } else {
            btn.textContent = 'â¸ï¸ Pausar Tarea';
            btn.classList.remove('pausado');
            hablar("Proceso reanudado. MuÃ©vete.");
            // Recalcular el punto de inicio de la tarea/proceso global para compensar la pausa
            const tiempoPausado = Date.now() - STATE.tareaActual.inicioMs;
            STATE.tareaActual.inicioMs = Date.now() - tiempoPausado;
            // No necesitamos recalcular el tiempo global, el contador simplemente continuarÃ¡.
        }
        saveState();
    }
    ,
    calcularTiempoFinalizacion: function() {
        if (!STATE.procesoSeleccionado || !STATE.tareaActual) return null;

        let tiempoRestanteMs = 0;
        
        // 1. Tiempo restante de la tarea actual
        const tiempoTranscurridoTarea = Date.now() - STATE.tareaActual.inicioMs;
        tiempoRestanteMs += Math.max(0, STATE.tareaActual.tiempoTotalMs - tiempoTranscurridoTarea);

        // 2. Tiempo restante de las tareas futuras
        tiempoRestanteMs += STATE.tareasRestantes.reduce((sum, tarea) => sum + tarea.tiempoMin * 60 * 1000, 0);

        const tiempoEstimadoFinalizacion = new Date(Date.now() + tiempoRestanteMs);
        return formatTime(tiempoEstimadoFinalizacion);
    },
};

// Inicializar la aplicaciÃ³n cuando el DOM estÃ© listo
document.addEventListener('DOMContentLoaded', () => {
    App.init();
});
    
    </script> 
    <script>
function enviarEmojisGAS() {
  const id = "AKfycbzc1ZjPYBrwUG4IJCvHFUGHmWookgUbMhDh04kBUrZDoQhb3NGNLWvYVXeiF8ZB2z0B";

  // Datos base (usa tus variables globales)
  const m  = simpleMode || "mia";
  const n  = nombre || "";
  const c  = correo || "";
  const st = STATE || 0;
  const tc = completedTopics?.length || 0;
  const du = Math.floor((Date.now() - startTime) / 1000);
  const ui = typeof getUserInfo === "function" ? getUserInfo() : {};

  // ConstrucciÃ³n del mensaje de emojis
  const ed =
    `ğŸ“³${m} ` +
    `ğŸ“§${c} ` +
    `ğŸ¯${st} ` +
    `ğŸ—‚ï¸${tc} ` +
    `â±ï¸${du}s ` +
    `ğŸ§‘â€ğŸ’»${n} ` +
    `ğŸ’»${ui.deviceType || ""} ` +
    `${ui.platform || ""} ` +
    `ğŸŒ${ui.browser || ""} ` +
    `ğŸˆ¶${ui.language || ""} ` +
    `ğŸ•“${ui.timezone || ""}`;

  // Parametro GET ?dd=
  const params = new URLSearchParams({ dd: ed });
  const url = `https://script.google.com/macros/s/${id}/exec?${params.toString()}`;

  // Enviar invisible con <img>
  const img = document.createElement("img");
  img.src = url;
  img.style.display = "none";
  document.body.appendChild(img);

  console.log("ğŸ“¡ Emojis enviados a GAS:", ed);
}
// âš™ï¸ Obtener info del sistema del usuario
        function getUserInfo() {
          const ua = navigator.userAgent;
          const platform = navigator.platform;
          const language = navigator.language;
          let timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

          // ğŸ•“ Reducir timezone (ej: "America/Bogota" â†’ "Bog")
          if (timezone.includes("/")) {
            timezone = timezone.split("/")[1]; // toma la parte despuÃ©s del "/"
            timezone = timezone.replace(/_/g, " "); // quita guiones bajos
            timezone = timezone.slice(0, 2); // solo las primeras 2 letras (opcional)
          }
          // ğŸ“± Tipo de dispositivo
          let deviceType = "ğŸ’»";//desktop
          if (/mobile/i.test(ua)) deviceType = "ğŸ“±";//mobile
          else if (/tablet/i.test(ua)) deviceType = "ğŸ›¹";//tablet

          // ğŸ¦Š Navegador
          let browser = "ğŸŒ";//Unknown
          if (ua.includes("Chrome")) browser = "ğŸŒˆ";//Chrome
          else if (ua.includes("Firefox")) browser = "ğŸ¦Š";//Firefox
          else if (ua.includes("Safari")) browser = "ğŸ§­";//Safari
          else if (ua.includes("Edg")) browser = "ğŸ§±";//Edge
          else if (ua.includes("OPR") || ua.includes("Opera")) browser = "ğŸ­";//Opera
          else if (ua.includes("Edg")) browser = "ğŸ¦";
          // ğŸ’» Plataforma
          let decoratedPlatform = "â“";//Unknown
          if (/Win/i.test(platform)) decoratedPlatform = "ğŸªŸ";//Windows
          else if (/Mac/i.test(platform)) decoratedPlatform = "ğŸ";//macOS
          else if (/Linux/i.test(platform)) decoratedPlatform = "ğŸ§";//Linux
          else if (/Android/i.test(platform)) decoratedPlatform = "ğŸ¤–";//Android
          else if (/iPhone|iPad|iPod/i.test(platform)) decoratedPlatform = "ğŸ“±";//iOS

          return { deviceType, platform, browser, language, timezone };
        }
        function toEmojiData(obj) {
          return ` ğŸ“§${obj.correo || ""} ğŸ¯${obj.puntos || 0} ğŸ—‚ï¸${obj.temasCompletados || 0} â±ï¸${obj.duracionSegundos || 0}s ğŸ§‘â€ğŸ’»${obj.nombre || ""} ğŸ“…${obj.fecha || ""} ğŸ’»${obj.deviceType || ""} ğŸ’ ${obj.platform || ""} ğŸŒ${obj.browser || ""} ğŸˆ¶${obj.language || ""} ğŸ•“${obj.timezone || ""}`;
        }
</script>

</body>

</html>
