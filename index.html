<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapeo de Trayectoria 3D</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>


<style>


    body {
    margin: 0;
    overflow: hidden;
    font-family: Arial, sans-serif;
}
#container {
    width: 100vw;
    height: 100vh;
}
#ui-overlay {
    position: absolute;
    top: 10px;
    left: 10px;
    color: white;
    background: rgba(0, 0, 0, 0.6);
    padding: 10px;
    border-radius: 5px;
    z-index: 100;
}
#startButton {
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
}
#debug-info {
    margin-top: 10px;
    font-size: 12px;
}
    
</style>

    
<body>
    <div id="container">
        </div>
    <div id="ui-overlay">
        <button id="startButton">INICIAR RASTREO (Start)</button>
        <div id="status">Esperando inicio...</div>
        <div id="debug-info">
            Altura Z: 0.00 m<br>
            Presión: 0.00 hPa<br>
            Deriva: 0.00 m/s
        </div>
    </div>
    <script>
      
// --- [ 1. CONFIGURACIÓN INICIAL DE THREE.JS ] ---
const container = document.getElementById('container');
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });

renderer.setSize(window.innerWidth, window.innerHeight);
container.appendChild(renderer.domElement);

scene.background = new THREE.Color(0x1a1a1a);
const light = new THREE.AmbientLight(0x404040); // soft white light
scene.add(light);
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
scene.add(directionalLight);

// Inicialmente, la cámara se coloca detrás y mirando al origen
camera.position.set(0, 5, 10);
camera.lookAt(0, 0, 0);

// Objeto que representa la trayectoria del usuario
const pathGeometry = new THREE.BufferGeometry();
const MAX_POINTS = 5000;
const positions = new Float32Array(MAX_POINTS * 3);
pathGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
const material = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 3 });
const line = new THREE.Line(pathGeometry, material);
scene.add(line);

// --- [ 2. FUSIÓN DE SENSORES Y VARIABLES DE ESTADO ] ---
let tracking = false;
const position = new THREE.Vector3(0, 0, 0); // Posición (x, y, z)
let velocity = new THREE.Vector3(0, 0, 0); // Velocidad (vx, vy, vz)
let orientation = 0; // Ángulo de rotación en el plano (Heading)
let numPoints = 0;

// Variables para PDR (Pedestrian Dead Reckoning)
let stepDetectionThreshold = 10.0; // Umbral de aceleración para detectar un paso
let stepLength = 0.75; // Longitud promedio de un paso en metros
let lastAcceleration = 0;

// Variables Barómetro
let seaLevelPressure = 1013.25; // Presión de referencia a nivel del mar (hPa)
let initialPressure = null; // Presión al inicio del tracking
let pressureAltitude = 0; // Altitud calculada por barómetro

// --- [ 3. PROCESAMIENTO DE DATOS DEL BARÓMETRO Y ALTITUD ] ---

// Fórmula barométrica para altitud (derivada de la ecuación hipsométrica)
function calculateAltitude(pressure, referencePressure) {
    if (pressure === 0 || referencePressure === 0) return 0;
    // La constante 1/5.257 es una aproximación de la atmósfera estándar
    return 44330 * (1.0 - Math.pow(pressure / referencePressure, 1 / 5.257));
}

function handlePressure(e) {
    const pressure = e.reading.pressure;
    document.getElementById('debug-info').innerHTML = `Presión: ${pressure.toFixed(2)} hPa`;

    if (initialPressure === null) {
        initialPressure = pressure;
        // Ajustamos la posición Z inicial a 0
        position.z = 0;
    }

    // Calculamos la altitud relativa usando la presión inicial como referencia
    // (Esto simula el cambio de piso o desnivel)
    const newAltitude = calculateAltitude(pressure, initialPressure);
    
    // Suavizado y aplicación al eje Y (Altura en Three.js)
    // Aplicamos una corrección suavizada (Factor de amortiguación: 0.1)
    position.y += (newAltitude - position.y) * 0.1;
    pressureAltitude = newAltitude;
}

// --- [ 4. PROCESAMIENTO DE DATOS INERCIALES (IMU) ] ---

function handleMotion(e) {
    if (!tracking) return;

    const dt = 1 / 60; // Asumiendo ~60 FPS/Hz
    
    // Aceleración (m/s^2)
    const acc = e.acceleration;

    // Orientación (Giroscopio)
    const gyro = e.rotationRate;
    // Acumular la rotación en el eje Y (vertical)
    orientation += gyro.y * dt;
    
    // --- [ DETECCIÓN DE PASOS (PDR) ] ---
    
    // Usamos la aceleración total (magnitud) para detectar un paso
    const magnitude = Math.sqrt(acc.x * acc.x + acc.y * acc.y + acc.z * acc.z);

    if (magnitude > stepDetectionThreshold && lastAcceleration <= stepDetectionThreshold) {
        // Paso detectado. 
        // 1. Calcular el desplazamiento (stepLength)
        // 2. Usar la orientación para proyectar en X y Z (plano horizontal)
        const dx = stepLength * Math.sin(orientation);
        const dz = stepLength * Math.cos(orientation);

        // Aplicamos el desplazamiento a la posición
        position.x += dx;
        position.z += dz;
        
        // El eje Y (altura) ya está siendo corregido por el barómetro
        
        // Agregar el punto a la geometría de la línea
        if (numPoints < MAX_POINTS) {
            positions[numPoints * 3] = position.x;
            positions[numPoints * 3 + 1] = position.y; 
            positions[numPoints * 3 + 2] = position.z;
            numPoints++;
            pathGeometry.setDrawRange(0, numPoints);
            pathGeometry.attributes.position.needsUpdate = true;
        }
    }
    lastAcceleration = magnitude;

    // Actualizar la cámara para seguir al usuario
    // Colocamos la cámara detrás del usuario, mirando hacia adelante
    camera.position.x = position.x - 5 * Math.sin(orientation);
    camera.position.y = position.y + 3; // Ligeramente por encima
    camera.position.z = position.z - 5 * Math.cos(orientation);
    
    camera.lookAt(position.x, position.y, position.z);
    
    // Actualizar la información de depuración
    document.getElementById('debug-info').innerHTML = `
        Altura Y (Baro): ${position.y.toFixed(2)} m<br>
        Presión Altitud: ${pressureAltitude.toFixed(2)} m<br>
        Orientación (Yaw): ${(orientation * 180 / Math.PI).toFixed(2)} °
    `;
}

// --- [ 5. INICIALIZACIÓN DE SENSORES Y BUCLE DE RENDERIZADO ] ---

// Función principal de inicialización
async function initTracking() {
    document.getElementById('status').innerText = 'Solicitando permisos...';
    
    // 1. Permisos (Solo en iOS se necesita la solicitud explícita)
    if (typeof DeviceMotionEvent.requestPermission === 'function') {
        const permission = await DeviceMotionEvent.requestPermission();
        if (permission !== 'granted') {
            document.getElementById('status').innerText = 'Permiso denegado para sensores de movimiento.';
            return;
        }
    }

    // 2. Inicialización del Acelerómetro/Giroscopio
    window.addEventListener('devicemotion', handleMotion);

    // 3. Inicialización del Barómetro (PressureSensor API, experimental y requiere HTTPS)
    try {
        if ('PressureSensor' in window) {
            const sensor = new PressureSensor({ frequency: 1 }); // 1Hz es suficiente
            sensor.onreading = handlePressure;
            sensor.onerror = (event) => {
                document.getElementById('status').innerText = 'Error con Barómetro. Usando solo IMU+PDR.';
            };
            sensor.start();
        } else {
             document.getElementById('status').innerText = 'Barómetro (PressureSensor) no soportado. Usando solo IMU+PDR.';
        }
    } catch (error) {
         document.getElementById('status').innerText = 'Excepción al iniciar Barómetro. Usando solo IMU+PDR.';
    }

    tracking = true;
    document.getElementById('status').innerText = 'RASTREANDO...';
}

// Bucle principal de renderizado (simula la cuerda o raya)
function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}

// --- [ 6. MANEJADOR DE EVENTOS ] ---

document.getElementById('startButton').addEventListener('click', () => {
    if (!tracking) {
        initTracking();
    }
});

// Ajustar la escena cuando la ventana cambie de tamaño
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// Iniciar el bucle de renderizado
animate();


        
    </script>
</body>
</html>
