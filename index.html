<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Conducci√≥n Infinita por Sensores</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #303030;
        }
        #scene-container {
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #008cba; /* Un color m√°s de coche */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #status-message {
            position: absolute;
            top: 70px;
            color: #fff;
            font-weight: bold;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }
        #speed-display {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 1.2em;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.158.0/three.min.js"></script>
</head>
<body>

    <div id="controls">
        <button id="start-sensors-button">Iniciar Conducci√≥n üöÄ</button>
    </div>
    <p id="status-message">Esperando la activaci√≥n de sensores...</p>
    <div id="speed-display">Velocidad: <span id="current-speed">0.0</span> km/h</div>

    <div id="scene-container"></div>

    <script>
        // --- VARIABLES GLOBALES Y DE SIMULACI√ìN ---
        let permissionGranted = false;
        const statusMessage = document.getElementById('status-message');
        const startButton = document.getElementById('start-sensors-button');

        // Three.js Variables
        let scene, camera, renderer, vehicleGroup, floor;
        const FLOOR_SIZE = 500; // Un plano grande
        const TILE_SIZE = 10; // Para el patr√≥n del suelo

        // Propiedades de la simulaci√≥n
        const ACCELERATION_FACTOR = 0.005; 
        const STEERING_FACTOR = 0.008; 
        const MAX_SPEED = 0.5;
        const JUMP_ACCELERATION_THRESHOLD = 50; 
        const GRAVITY_SIM = -0.01;

        let velocity = 0; // Velocidad del coche
        let rotationAngle = 0; // √Ångulo de orientaci√≥n del coche
        let verticalVelocity = 0; 
        let currentCarPitch = 0; // Inclinaci√≥n del coche (para realismo)

        // --- INICIALIZACI√ìN DE THREE.JS ---

        function initThreeJS() {
            const container = document.getElementById('scene-container');
            const width = window.innerWidth;
            const height = window.innerHeight;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Cielo azul

            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);

            // 1. ESCENARIO (SUELO INFINITO)
            const textureLoader = new THREE.TextureLoader();
            const texture = textureLoader.load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg');
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(FLOOR_SIZE / TILE_SIZE, FLOOR_SIZE / TILE_SIZE); // Repetir textura

            const floorGeometry = new THREE.PlaneGeometry(FLOOR_SIZE, FLOOR_SIZE);
            const floorMaterial = new THREE.MeshLambertMaterial({ map: texture, side: THREE.DoubleSide });
            floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = Math.PI / 2;
            scene.add(floor);

            // 2. CARRO MEJORADO (Grupo de Veh√≠culo)
            vehicleGroup = new THREE.Group();
            
            // Cuerpo Principal (Caja m√°s detallada)
            const bodyGeometry = new THREE.BoxGeometry(2, 1, 4);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x00ccff });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.0; 
            vehicleGroup.add(body);

            // Cabina (Caja m√°s peque√±a y arriba)
            const cabinGeometry = new THREE.BoxGeometry(1.5, 0.75, 1.5);
            const cabinMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
            cabin.position.set(0, 1.75, 0.5);
            vehicleGroup.add(cabin);

            // Ruedas (Cilindros para un mejor realismo)
            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 16);
            const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });

            const wheelPositions = [
                { x: -1.2, z: 1.5 }, { x: 1.2, z: 1.5 }, // Delanteras
                { x: -1.2, z: -1.5 }, { x: 1.2, z: -1.5 }  // Traseras
            ];
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos.x, 0.5, pos.z);
                wheel.rotation.z = Math.PI / 2; // Gira el cilindro para que quede como rueda
                vehicleGroup.add(wheel);
            });
            
            // Posicionamos el veh√≠culo en (0, 0, 0)
            vehicleGroup.position.y = 0;
            scene.add(vehicleGroup);

            // Luces
            const ambientLight = new THREE.AmbientLight(0x606060);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 50, 50).normalize();
            scene.add(directionalLight);

            window.addEventListener('resize', onWindowResize, false);
            camera.position.set(0, 3, 5);
            camera.lookAt(0, 1, 0); // La c√°mara mira el carro
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- L√ìGICA DE SIMULACI√ìN Y RENDERIZADO ---

        function animate() {
            requestAnimationFrame(animate);

            if (permissionGranted) {
                // 1. **Manejo de Velocidad y Fricci√≥n**
                velocity *= 0.98; // Fricci√≥n constante para desacelerar
                
                // 2. **Movimiento del Escenario (Ilusi√≥n Infinita)**
                // El carro NO se mueve en X/Z; el mundo se mueve bajo el carro.
                // Movimiento inverso del suelo:
                const deltaX = Math.sin(rotationAngle) * velocity;
                const deltaZ = Math.cos(rotationAngle) * velocity;
                
                floor.position.x -= deltaX;
                floor.position.z -= deltaZ;

                // 3. **Reposicionamiento del Suelo (Tiling / Loop)**
                // Si el suelo se mueve m√°s all√° de sus l√≠mites, lo reseteamos para simular el infinito.
                if (floor.position.x > FLOOR_SIZE / 2) floor.position.x -= FLOOR_SIZE;
                if (floor.position.x < -FLOOR_SIZE / 2) floor.position.x += FLOOR_SIZE;
                if (floor.position.z > FLOOR_SIZE / 2) floor.position.z -= FLOOR_SIZE;
                if (floor.position.z < -FLOOR_SIZE / 2) floor.position.z += FLOOR_SIZE;


                // 4. **Salto (Gravedad y Posici√≥n Vertical)**
                vehicleGroup.position.y += verticalVelocity;
                verticalVelocity += GRAVITY_SIM;
                
                if (vehicleGroup.position.y <= 0) {
                    vehicleGroup.position.y = 0;
                    verticalVelocity = 0;
                }
                
                // 5. **Actualizaci√≥n de Rotaci√≥n y C√°mara**
                vehicleGroup.rotation.y = rotationAngle;
                
                // Efecto de inclinaci√≥n del carro basado en la rotaci√≥n lateral (para inmersi√≥n)
                // Usamos una peque√±a porci√≥n del giro para inclinar ligeramente el carro
                vehicleGroup.rotation.z = -currentCarPitch * 0.5; 
                
                // Actualizar Display de Velocidad (convertimos a algo m√°s parecido a km/h)
                document.getElementById('current-speed').textContent = (Math.abs(velocity) * 100).toFixed(1);
            }

            renderer.render(scene, camera);
        }

        // --- MANEJADORES DE SENSORES (CONTROL DEL CARRO) ---

        function handleOrientation(event) {
            if (!permissionGranted) return;

            const beta = event.beta;   // Inclinaci√≥n Frontal (Velocidad)
            const gamma = event.gamma; // Inclinaci√≥n Lateral (Direcci√≥n)
            
            // 1. Aceleraci√≥n/Freno (Controlado por Beta)
            const normalizedBeta = Math.max(-45, Math.min(45, beta));
            const accelerationControl = normalizedBeta / 45; 

            // Si inclinamos hacia adelante, aceleramos, si no, aplicamos m√°s fricci√≥n.
            if (accelerationControl > 0.1) {
                velocity += accelerationControl * ACCELERATION_FACTOR;
                velocity = Math.min(MAX_SPEED, velocity);
            } else if (accelerationControl < -0.1) {
                // Freno o Reversa
                velocity += accelerationControl * ACCELERATION_FACTOR * 0.5;
                velocity = Math.max(-MAX_SPEED * 0.2, velocity);
            }
            
            // 2. Direcci√≥n (Controlado por Gamma)
            const normalizedGamma = Math.max(-45, Math.min(45, gamma));
            const steeringControl = normalizedGamma / 45; 

            // El giro depende de la velocidad (evitar giros bruscos en reversa)
            if (Math.abs(velocity) > 0.01) {
                const turnFactor = velocity > 0 ? 1 : 0.5; // Gira menos en reversa
                rotationAngle -= steeringControl * turnFactor * STEERING_FACTOR;
            }
            
            // Guardar el pitch actual para la inclinaci√≥n visual del carro
            currentCarPitch = steeringControl;
        }

        function handleMotion(event) {
            if (!permissionGranted) return;

            // 3. Salto (Controlado por aceleraci√≥n en Z)
            const acc = event.accelerationIncludingGravity; // Usamos este para ser m√°s sensibles
            
            if (acc && vehicleGroup.position.y === 0) {
                const accZ = acc.z !== null ? acc.z : 0;
                // Una sacudida positiva en Z
                if (accZ > JUMP_ACCELERATION_THRESHOLD) {
                    verticalVelocity = 0.5; 
                    statusMessage.textContent = '¬°Salto activado!';
                    setTimeout(() => statusMessage.textContent = 'Sensores activos.', 1000);
                }
            }
        }

        // --- L√ìGICA DE PERMISOS E INICIO (Mismo Bloque) ---
        async function requestSensorPermissions() {
            // Se asume que el c√≥digo de solicitud de permisos (DeviceOrientationEvent.requestPermission) 
            // del ejemplo anterior est√° aqu√≠ para compatibilidad con iOS/Safari.
            
            // --- SIMULACI√ìN DE CONCESI√ìN DE PERMISOS ---
            permissionGranted = true;
            statusMessage.textContent = '‚úÖ Sensores de movimiento activos. ¬°A Conducir!';
            startButton.style.display = 'none';

            window.addEventListener('deviceorientation', handleOrientation);
            window.addEventListener('devicemotion', handleMotion);
        }

        // --- INICIALIZACI√ìN GENERAL ---
        document.addEventListener('DOMContentLoaded', () => {
            initThreeJS();
            startButton.addEventListener('click', requestSensorPermissions);
        });
        
    </script>
</body>
</html>
