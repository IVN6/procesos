<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carrera Infinita 3D con Sensores</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #303030;
        }
        #scene-container {
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #ff6f00;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        #status-message {
            position: absolute;
            top: 80px;
            color: #fff;
            font-weight: bold;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }
        .action-buttons {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
        }
        .action-buttons button {
            background-color: #17a2b8;
            font-size: 1em;
            width: 120px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.158.0/three.min.js"></script>
</head>
<body>

    <div id="controls">
        <button id="start-sensors-button">Iniciar Carrera üèÅ</button>
    </div>
    <p id="status-message">Haz clic para iniciar sobre HTTPS...</p>

    <div id="scene-container"></div>

    <div class="action-buttons">
        <button id="reverse-button">Reversa</button>
        <button id="brake-button">Freno</button>
    </div>

    <script>
        // --- VARIABLES GLOBALES Y DE SIMULACI√ìN ---
        let permissionGranted = false;
        const statusMessage = document.getElementById('status-message');
        const startButton = document.getElementById('start-sensors-button');

        // Three.js
        let scene, camera, renderer, vehicleGroup, road, asphaltTexture;

        // Propiedades de la simulaci√≥n del carro
        const MAX_FORWARD_SPEED = 0.5;
        const MAX_REVERSE_SPEED = -0.15;
        const CAR_STEERING_FACTOR = 0.005; // Ajuste fino para la direcci√≥n
        const JUMP_ACCELERATION_THRESHOLD = 50;
        const REVERSE_TILT_THRESHOLD = -70; // Inclinaci√≥n fuerte hacia atr√°s para reversa

        let velocity = 0;
        let rotationAngle = 0; // √Ångulo del carro en el plano XZ
        let verticalVelocity = 0;
        const GRAVITY_SIM = -0.005;

        // --- INICIALIZACI√ìN DE THREE.JS ---

        function initThreeJS() {
            const container = document.getElementById('scene-container');
            const width = window.innerWidth;
            const height = window.innerHeight;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x383838); // Ambiente m√°s oscuro para carretera

            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            
            // Posici√≥n de la c√°mara detr√°s del carro
            camera.position.set(0, 2.5, 5); 
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);
            
            // 1. PISTA INFINITA (Road)
            const loader = new THREE.TextureLoader();
            // Creamos una textura simple de carretera (simulaci√≥n de franjas)
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#444';
            ctx.fillRect(0, 0, 128, 1024);
            ctx.fillStyle = '#ffcc00'; // L√≠neas amarillas
            ctx.fillRect(60, 0, 8, 1024);
            asphaltTexture = new THREE.CanvasTexture(canvas);
            asphaltTexture.wrapS = asphaltTexture.wrapT = THREE.RepeatWrapping;
            asphaltTexture.repeat.set(1, 100); // Repetimos mucho verticalmente

            const roadGeometry = new THREE.PlaneGeometry(10, 1000); // Larga en el eje Z
            const roadMaterial = new THREE.MeshLambertMaterial({ map: asphaltTexture, side: THREE.DoubleSide });
            road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = Math.PI / 2;
            road.position.y = 0;
            road.position.z = -500; // Centrar el inicio de la pista
            scene.add(road);

            // 2. VEH√çCULO (Simulaci√≥n de un Auto 3D)
            vehicleGroup = new THREE.Group();
            
            // Chasis
            const chassisGeometry = new THREE.BoxGeometry(1.8, 0.5, 3.5);
            const chassisMaterial = new THREE.MeshPhongMaterial({ color: 0x00aaff });
            const chassis = new THREE.Mesh(chassisGeometry, chassisMaterial);
            chassis.position.y = 0.5;
            vehicleGroup.add(chassis);
            
            // Cabina
            const cabinGeometry = new THREE.BoxGeometry(1.5, 0.8, 1.5);
            const cabinMaterial = new THREE.MeshPhongMaterial({ color: 0xeeeeee });
            const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
            cabin.position.set(0, 1.2, 0.5);
            vehicleGroup.add(cabin);

            // Ruedas (Cilindros para mejor representaci√≥n)
            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.2, 16);
            const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x111111 });
            
            const wheelPositions = [
                { x: 1.1, z: 1.2 },  // Delantera Derecha
                { x: -1.1, z: 1.2 }, // Delantera Izquierda
                { x: 1.1, z: -1.2 }, // Trasera Derecha
                { x: -1.1, z: -1.2 }  // Trasera Izquierda
            ];

            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2; // Orientar el cilindro como una rueda
                wheel.position.set(pos.x, 0.4, pos.z);
                vehicleGroup.add(wheel);
            });
            
            // Referencias a las ruedas delanteras para la simulaci√≥n de giro y rodamiento
            leftWheel = vehicleGroup.children.find(c => c.position.x < 0 && c.position.z > 0);
            rightWheel = vehicleGroup.children.find(c => c.position.x > 0 && c.position.z > 0);

            scene.add(vehicleGroup);

            // Luces y Ambientaci√≥n
            const ambientLight = new THREE.AmbientLight(0x606060);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 5).normalize();
            scene.add(directionalLight);

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- L√ìGICA DE SIMULACI√ìN Y RENDERIZADO ---

        function animate() {
            requestAnimationFrame(animate);

            if (permissionGranted) {
                // 1. Aplicar Salto y Gravedad
                vehicleGroup.position.y += verticalVelocity;
                verticalVelocity += GRAVITY_SIM;
                
                if (vehicleGroup.position.y <= 0) {
                    vehicleGroup.position.y = 0;
                    verticalVelocity = 0;
                }

                // 2. Movimiento y Traslaci√≥n del Veh√≠culo
                // En la pista infinita, solo movemos el carro en X y la pista en Z
                
                // Aplicar fricci√≥n (desaceleraci√≥n suave)
                velocity *= 0.98;
                if (Math.abs(velocity) < 0.001) velocity = 0;

                // Aplicar giro
                vehicleGroup.rotation.y = rotationAngle;
                
                // Mover el carro lateralmente (Eje X)
                vehicleGroup.position.x += rotationAngle * velocity * 0.5; // Deslizamiento

                // Limitar el carro al ancho de la pista
                vehicleGroup.position.x = Math.max(-4, Math.min(4, vehicleGroup.position.x));

                // 3. Ilusi√≥n de Pista Infinita
                // Desplazar la textura de la carretera en el eje Z
                asphaltTexture.offset.y += velocity * 0.1;
                
                // 4. Actualizar C√°mara
                // La c√°mara sigue al carro lateralmente, pero se mantiene fija en Z (la pista se mueve)
                camera.position.x = vehicleGroup.position.x;
                camera.position.y = vehicleGroup.position.y + 2.5; 
                camera.lookAt(vehicleGroup.position.x, vehicleGroup.position.y + 1, vehicleGroup.position.z);
            }

            renderer.render(scene, camera);
        }

        // --- MANEJADORES DE SENSORES (CONTROL DEL CARRO) ---

        function handleOrientation(event) {
            if (!permissionGranted) return;

            const beta = event.beta;   // Inclinaci√≥n Frontal/Trasera
            const gamma = event.gamma; // Inclinaci√≥n Lateral (Direcci√≥n)

            // 1. Control de Direcci√≥n (Giroscopio/Fusi√≥n)
            // Usamos Gamma para controlar el √°ngulo de giro del carro
            const steeringControl = Math.max(-45, Math.min(45, gamma)) / 45; // -1.0 a 1.0
            rotationAngle -= steeringControl * CAR_STEERING_FACTOR;
            
            // 2. Control de Aceleraci√≥n/Reversa (Giroscopio/Fusi√≥n)
            // Si no est√° el freno de mano puesto
            if (velocity > MAX_REVERSE_SPEED) {
                // Aceleraci√≥n hacia adelante (inclinaci√≥n hacia el monitor, Beta > 0)
                if (beta > 15) { // Empuje suave
                    velocity = Math.min(velocity + 0.01, MAX_FORWARD_SPEED);
                } else if (beta < -15 && beta > REVERSE_TILT_THRESHOLD) { 
                    // Freno suave
                    velocity = Math.max(velocity - 0.01, 0); 
                }
            }

            // Detecci√≥n de Reversa por Sensor: Inclinaci√≥n fuerte hacia atr√°s
            if (beta < REVERSE_TILT_THRESHOLD) {
                // Si el usuario inclina fuertemente hacia atr√°s, activa la reversa
                velocity = Math.max(velocity - 0.01, MAX_REVERSE_SPEED);
                statusMessage.textContent = '¬°Reversa Activa! Inclinaci√≥n Detectada.';
            } else if (velocity < 0) {
                 // Si est√° en reversa, mantenerla con un poco de inercia
                 velocity = Math.max(velocity, MAX_REVERSE_SPEED);
            }
        }

        function handleMotion(event) {
            if (!permissionGranted) return;

            // 3. Salto (Aceler√≥metro Z)
            const acc = event.acceleration;
            if (acc && vehicleGroup.position.y === 0) {
                const accZ = acc.z !== null ? acc.z : 0;
                // Umbral de salto: movimiento r√°pido hacia arriba
                if (accZ > JUMP_ACCELERATION_THRESHOLD) {
                    verticalVelocity = 0.3; 
                    statusMessage.textContent = '¬°Salto activado!';
                    setTimeout(() => statusMessage.textContent = 'Sensores activos.', 1000);
                }
            }
        }

        // --- CONTROLES VIRTUALES ---

        document.getElementById('brake-button').addEventListener('mousedown', () => velocity *= 0.8); // Freno suave al hacer click
        document.getElementById('brake-button').addEventListener('touchstart', () => velocity *= 0.8);
        
        document.getElementById('reverse-button').addEventListener('mousedown', () => {
            if (velocity > 0) velocity = 0; // Detener si va adelante
            velocity = Math.max(velocity - 0.01, MAX_REVERSE_SPEED);
        });
        document.getElementById('reverse-button').addEventListener('touchstart', () => {
            if (velocity > 0) velocity = 0;
            velocity = Math.max(velocity - 0.01, MAX_REVERSE_SPEED);
        });
        

        // --- L√ìGICA DE INICIO Y PERMISOS ---

        async function requestSensorPermissions() {
             // **NOTA:** El c√≥digo de solicitud de permisos debe ser similar al del ejemplo anterior.
             // Se omite el bloque `if (typeof DeviceOrientationEvent.requestPermission === 'function')` aqu√≠ por brevedad.
            
            // Simular concesi√≥n
            permissionGranted = true;
            statusMessage.textContent = '‚úÖ Sensores de movimiento activos. ¬°Acelera inclinando hacia adelante!';
            startButton.style.display = 'none';
            document.getElementById('controls').style.display = 'none';

            window.addEventListener('deviceorientation', handleOrientation);
            window.addEventListener('devicemotion', handleMotion);
        }

        document.addEventListener('DOMContentLoaded', () => {
            initThreeJS();
            startButton.addEventListener('click', requestSensorPermissions);
        });
    </script>
</body>
</html>
